import asyncio
from fastapi import FastAPI, HTTPException, Depends, Security
from fastapi.security import APIKeyHeader
from pydantic import BaseModel
from typing import Optional, List, Dict
import logging

# Import your GovernanceIntrusionContainment core here
# from governance_module import GovernanceIntrusionContainment

logger = logging.getLogger("containment_api")
if not logger.hasHandlers():
    handler = logging.StreamHandler()
    formatter = logging.Formatter("[%(asctime)s][%(levelname)s] %(message)s")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
logger.setLevel(logging.INFO)

API_KEY_HEADER = "X-API-KEY"
api_key_header = APIKeyHeader(name=API_KEY_HEADER, auto_error=True)

VALID_API_KEYS = {"your-secure-api-key"}  # Replace with real key management

async def verify_api_key(api_key: str = Security(api_key_header)):
    if api_key not in VALID_API_KEYS:
        logger.warning(f"Unauthorized API key attempted: {api_key}")
        raise HTTPException(status_code=403, detail="Invalid API Key")
    return api_key


class MultiSigRequest(BaseModel):
    action_id: str
    signer_id: str
    signature: str  # e.g. base64-encoded signature


class AnomalyMetrics(BaseModel):
    metrics: Dict[str, float]
    timestamp: Optional[float] = None


class SystemStatusResponse(BaseModel):
    containment_engaged: bool
    last_integrity_check: Optional[str]
    pending_signatures: List[str]


app = FastAPI(
    title="Governance Intrusion Containment API",
    description="API for managing security & containment on Interactive Guy AGI",
    version="1.0.0",
    docs_url="/docs",
    redoc_url=None,
)


# Dependency for GovernanceIntrusionContainment singleton
# In real system, replace with proper application lifecycle management
gic_instance = None


def get_gic() -> GovernanceIntrusionContainment:
    global gic_instance
    if gic_instance is None:
        # Initialize with your knowledge graph from persistence or blank
        gic_instance = GovernanceIntrusionContainment(core_knowledge_graph={})
    return gic_instance


@app.post("/containment/request-multisig", status_code=202)
async def request_multisig(
    request: MultiSigRequest,
    gic: GovernanceIntrusionContainment = Depends(get_gic),
    api_key: str = Depends(verify_api_key),
):
    verify_signature = getattr(gic, "verify_signature_hook", lambda s, a: True)
    if not await verify_signature(request.signer_id, request.action_id):
        raise HTTPException(status_code=401, detail="Invalid multisig signature")

    success = await gic.request_multi_signature(
        action_id=request.action_id, signer_id=request.signer_id
    )
    remaining = max(0, gic.multi_sig_threshold - len(gic.pending_signatures))
    return {"success": success, "signatures_remaining": remaining}


@app.post("/containment/report-anomaly", status_code=202)
async def report_anomaly(
    metrics: AnomalyMetrics,
    gic: GovernanceIntrusionContainment = Depends(get_gic),
    api_key: str = Depends(verify_api_key),
):
    await gic.monitor_anomalies(metrics.metrics)
    return {"containment_engaged": gic.containment_engaged}


@app.get("/containment/status", response_model=SystemStatusResponse)
async def containment_status(
    gic: GovernanceIntrusionContainment = Depends(get_gic),
    api_key: str = Depends(verify_api_key),
):
    last_check = getattr(gic, "integrity_hash_history", None)
    last_integrity = last_check[-1] if last_check else None
    return SystemStatusResponse(
        containment_engaged=gic.containment_engaged,
        last_integrity_check=last_integrity,
        pending_signatures=list(gic.pending_signatures),
    )


@app.post("/containment/force-rollback", status_code=202)
async def force_rollback(
    gic: GovernanceIntrusionContainment = Depends(get_gic),
    api_key: str = Depends(verify_api_key),
):
    if not gic.containment_engaged:
        raise HTTPException(status_code=400, detail="Containment not currently engaged")
    success = await gic.rollback_to_last_safe_state()
    return {"success": success}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
