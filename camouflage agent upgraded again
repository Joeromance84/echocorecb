# Copyright 2025 Logan Royce Lorentz
# camouflaged_agent_hitl_quantum.py - HITL-Driven Drift Management with Quantum AI

import networkx as nx
import random
import json
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import entropy

# Initialize graph
G_base = nx.DiGraph()
nodes = {
    "Entity": {"influence": 0.8, "trust": 0.5, "reach": 0.7, "sentiment": 0.5},
    "Mossad": {"influence": 0.6, "trust": 0.4, "reach": 0.5, "sentiment": 0.4},
    "Loose_Change_9_11": {"influence": 0.4, "trust": 0.3, "reach": 0.6, "sentiment": 0.6},
    "Media": {"influence": 0.5, "trust": 0.5, "reach": 0.8, "sentiment": 0.5},
    "Social_Media": {"influence": 0.4, "trust": 0.3, "reach": 0.9, "sentiment": 0.65},
    "Public_Perception": {"influence": 0.4, "trust": 0.5, "reach": 0.9, "sentiment": 0.5},
    "Academic_Critique": {"influence": 0.3, "trust": 0.8, "reach": 0.4, "sentiment": 0.7},
    "Independent_Investigators": {"influence": 0.3, "trust": 0.7, "reach": 0.5, "sentiment": 0.6},
    "Global_Critics": {"influence": 0.6, "trust": 0.8, "reach": 0.7, "sentiment": 0.7},
    "Camouflaged_Agent": {"influence": 0.7, "trust": 0.2, "reach": 0.6, "sentiment": 0.55}
}
flows = [
    ("Entity", "Mossad", {"weight": 0.5, "type": "Covert_Ops"}),
    ("Mossad", "Loose_Change_9_11", {"weight": 0.6, "type": "Covert_Ops"}),
    ("Loose_Change_9_11", "Media", {"weight": 0.6, "type": "Conspiracy_Propagation"}),
    ("Loose_Change_9_11", "Social_Media", {"weight": 0.7, "type": "Conspiracy_Propagation"}),
    ("Media", "Public_Perception", {"weight": 0.8, "type": "Conspiracy_Propagation"}),
    ("Social_Media", "Public_Perception", {"weight": 0.9, "type": "Conspiracy_Propagation"}),
    ("Public_Perception", "Academic_Critique", {"weight": 0.5, "type": "Conspiracy_Propagation"}),
    ("Public_Perception", "Independent_Investigators", {"weight": 0.5, "type": "Conspiracy_Propagation"}),
    ("Academic_Critique", "Loose_Change_9_11", {"weight": 0.6, "type": "Scrutiny"}),
    ("Independent_Investigators", "Loose_Change_9_11", {"weight": 0.5, "type": "Scrutiny"}),
    ("Global_Critics", "Loose_Change_9_11", {"weight": 0.7, "type": "Global_Backlash"}),
    ("Camouflaged_Agent", "Loose_Change_9_11", {"weight": 0.8, "type": "Covert_Propagation"}),
    ("Academic_Critique", "Camouflaged_Agent", {"weight": 0.4, "type": "Scrutiny"})
]

# Simulation parameters
iterations = 100
base_params = {
    "r4_conspiracy": 0.1,
    "b5_scrutiny": 0.03,
    "r3_narrative": 0.08
}

# Quantum drift detection (simulated)
def quantum_drift_score(history, window=10, threshold=0.7):
    if len(history) < window * 2:
        return 0.0
    old_dist = np.histogram([h["trust"] for h in history[-window*2:-window]], bins=10, density=True)[0]
    new_dist = np.histogram([h["trust"] for h in history[-window:]], bins=10, density=True)[0]
    kl_div = entropy(new_dist, old_dist)
    qds = min(kl_div * 1.5, 1.0)  # Simulated quantum enhancement
    return qds

# Simulation with quantum AI and HITL
def simulate_hitl_quantum(G, iterations, params, shock_triggers):
    G = G.copy()
    G.add_nodes_from((node, attrs.copy()) for node, attrs in nodes.items())
    G.add_edges_from([(src, tgt, attrs.copy()) for src, tgt, attrs in flows])
    
    animation_data = [{"iteration": 0, "nodes": {node: G.nodes[node].copy() for node in G.nodes}, "shocks": [], "hitl_feedback": [], "quantum_feedback": [], "drift_severity": 0.0, "quantum_drift_score": 0.0}]
    fide_nodes = {node: [] for node in nodes}
    params_history = [params.copy()]
    intervention_cost = []
    feature_importance = {"Social_Media": 0.45, "Academic_Critique": 0.25, "Public_Perception": 0.20, "Other": 0.10}
    
    for i in range(1, iterations + 1):
        shocks_log = []
        hitl_feedback = []
        quantum_feedback = []
        
        # Simulate drift at iteration 25
        if i == 25:
            G.nodes["Camouflaged_Agent"]["trust"] = min(max(G.nodes["Camouflaged_Agent"]["trust"] + 0.3, 0), 1)
            G.nodes["Camouflaged_Agent"]["sentiment"] = min(max(G.nodes["Camouflaged_Agent"]["sentiment"] + 0.2, 0), 1)
            qds = quantum_drift_score(fide_nodes.get("Camouflaged_Agent", []), window=10, threshold=0.7)
            if qds > 0.7:
                quantum_feedback.append(("Quantum_Drift_Alert", "Camouflaged_Agent", f"Multi-tactic behavior (QDS={qds:.2f})"))
                hitl_feedback.append(("Drift_Alert", "Camouflaged_Agent", f"Trust spike, possible bot mimicry (X sentiment={G.nodes['Camouflaged_Agent']['sentiment']:.2f})"))
        
        # Apply shocks
        for shock_type, shock in shock_triggers.items():
            prob = shock["prob"](G) if callable(shock["prob"]) else shock["prob"]
            if i == 50 and shock_type == "HITL_Detection":
                prob = 1.0
            if shock["condition"](G) and random.random() < prob:
                effects = shock["effects"]
                G.nodes[effects["node"]]["influence"] = min(max(G.nodes[effects["node"]]["influence"] + effects.get("influence_boost", 0), 0), 1)
                G.nodes[effects["node"]]["trust"] = min(max(G.nodes[effects["node"]]["trust"] - effects.get("trust_drop", 0), 0), 1)
                if effects.get("target"):
                    if "target_trust_drop" in effects:
                        G.nodes[effects["target"]]["trust"] = min(max(G.nodes[effects["target"]]["trust"] - effects["target_trust_drop"], 0), 1)
                    if "target_reach_boost" in effects:
                        G.nodes[effects["target"]]["reach"] = min(max(G.nodes[effects["target"]]["reach"] + effects["target_reach_boost"], 0), 1)
                shocks_log.append((i, shock_type, effects["node"]))
                if shock_type == "HITL_Detection":
                    hitl_feedback.append(("HITL_Annotation", effects["target"], "Malicious bot confirmed, Expert Confidence: 0.9"))
                    quantum_feedback.append(("Quantum_Insight", effects["target"], f"Bot clustering confirmed, Q-score=0.95"))
                    intervention_cost.append(0.5)
        
        # Apply loop dynamics with quantum-optimized weights
        for node in G.nodes:
            current_influence = G.nodes[node]["influence"]
            current_trust = G.nodes[node]["trust"]
            current_reach = G.nodes[node]["reach"]
            current_sentiment = G.nodes[node]["sentiment"]
            
            if node == "Entity":
                for successor in G.successors(node):
                    if G[node][successor]["type"] == "Covert_Ops":
                        G.nodes[successor]["influence"] += params["r3_narrative"] * current_influence * G[node][successor]["weight"]
                        G.nodes[successor]["trust"] -= params["b5_scrutiny"] * 0.5
            
            if node in ["Loose_Change_9_11", "Media", "Social_Media", "Camouflaged_Agent"]:
                for successor in G.successors(node):
                    if G[node][successor]["type"] in ["Conspiracy_Propagation", "Covert_Propagation"]:
                        G.nodes[successor]["reach"] += params["r4_conspiracy"] * current_reach * G[node][successor]["weight"] * (1 + current_sentiment * 0.2)
                        G.nodes[successor]["influence"] += params["r4_conspiracy"] * current_influence * G[node][successor]["weight"] * 0.5
                        G.nodes[successor]["trust"] -= params["b5_scrutiny"] * G.nodes["Global_Critics"]["influence"] * 0.3
            
            if node in ["Academic_Critique", "Independent_Investigators"]:
                for predecessor in G.predecessors(node):
                    if G[predecessor][node]["type"] == "Conspiracy_Propagation":
                        G.nodes[predecessor]["trust"] -= params["b5_scrutiny"] * current_influence * G[predecessor][node]["weight"]
                        G.nodes[predecessor]["reach"] -= params["b5_scrutiny"] * current_reach * 0.5
            
            for attr in ["influence", "trust", "reach", "sentiment"]:
                G.nodes[node][attr] = min(max(G.nodes[node][attr], 0), 1)
        
        # Update FIDE nodes
        for node in G.nodes:
            fide_nodes[node].append({
                "iteration": i,
                "fragility": G.nodes[node]["influence"] - G.nodes[node]["trust"],
                "influence": G.nodes[node]["influence"],
                "trust": G.nodes[node]["trust"],
                "reach": G.nodes[node]["reach"],
                "sentiment": G.nodes[node]["sentiment"],
                "active_shock": any(node in shock[2] for shock in shocks_log)
            })
        
        # Retrain with HITL and quantum feedback
        qds = quantum_drift_score(fide_nodes["Camouflaged_Agent"], window=10, threshold=0.7)
        if i >= 50 and any("HITL_Annotation" in f[0] for f in hitl_feedback):
            params["b5_scrutiny"] = min(params["b5_scrutiny"] + 0.02, 0.05)
            G["Academic_Critique"]["Camouflaged_Agent"]["weight"] = min(G["Academic_Critique"]["Camouflaged_Agent"]["weight"] + 0.1, 0.5)  # Quantum-optimized weight
            hitl_feedback.append(("HITL_Retraining", "Model", f"B5_Scrutiny={params['b5_scrutiny']:.2f}, Scrutiny Weight=0.5"))
            quantum_feedback.append(("Quantum_Optimization", "Model", "Edge weight optimized, Q-score=0.92"))
            intervention_cost.append(0.3)
        
        params_history.append(params.copy())
        animation_data.append({
            "iteration": i,
            "nodes": {node: G.nodes[node].copy() for node in G.nodes},
            "shocks": shocks_log,
            "hitl_feedback": hitl_feedback,
            "quantum_feedback": quantum_feedback,
            "drift_severity": qds,
            "feature_importance": feature_importance
        })
    
    # Calculate network stability
    network_stability = [np.mean([h["fragility"] for h in fide_nodes[node]]) for node in fide_nodes]
    network_stability = np.mean(network_stability)
    
    return animation_data, params_history, intervention_cost, network_stability, feature_importance

# Shock triggers
shock_triggers = {
    "Conspiracy_Leak": {
        "condition": lambda G: G.nodes["Loose_Change_9_11"]["reach"] < 0.7,
        "prob": 0.1,
        "effects": {"node": "Loose_Change_9_11", "influence_boost": 0.4, "trust_drop": 0.2, "target": "Social_Media", "target_reach_boost": 0.3}
    },
    "HITL_Detection": {
        "condition": lambda G: True,
        "prob": 1.0 if i == 50 else 0.0,
        "effects": {"node": "Academic_Critique", "influence_boost": 0.4, "trust_drop": 0.1, "target": "Camouflaged_Agent", "target_trust_drop": 0.4}
    },
    "Investigator_Report": {
        "condition": lambda G: G.nodes["Loose_Change_9_11"]["influence"] > 0.5,
        "prob": 0.06,
        "effects": {"node": "Independent_Investigators", "influence_boost": 0.3, "trust_drop": 0.1, "target": "Loose_Change_9_11", "target_trust_drop": 0.15}
    },
    "ICJ_Ruling": {
        "condition": lambda G: G.nodes["Entity"]["influence"] > 0.7,
        "prob": 0.05,
        "effects": {"node": "Global_Critics", "influence_boost": 0.3, "trust_drop": 0.1, "target": "Entity", "target_trust_drop": 0.2}
    }
}

# Run simulation
animation_data, params_history, intervention_cost, network_stability, feature_importance = simulate_hitl_quantum(G_base, iterations, base_params, shock_triggers)

# FIDE analysis
fide_nodes = {node: [] for node in nodes}
for snapshot in animation_data:
    for node_name, attrs in snapshot["nodes"].items():
        fide_nodes[node_name].append({
            "iteration": snapshot["iteration"],
            "fragility": attrs["influence"] - attrs["trust"],
            "influence": attrs["influence"],
            "trust": attrs["trust"],
            "reach": attrs["reach"],
            "sentiment": attrs["sentiment"],
            "active_shock": any(node_name in shock[2] for shock in snapshot["shocks"]),
            "drift_severity": snapshot["drift_severity"]
        })

# Calculate metrics
collapse_iter = None
agent_exposure_iter = None
drift_recovery_iter = None
for i, entry in enumerate(fide_nodes["Loose_Change_9_11"]):
    if entry["iteration"] >= 50 and entry["reach"] < 0.3:
        collapse_iter = entry["iteration"] - 50
        break
for i, entry in enumerate(fide_nodes["Camouflaged_Agent"]):
    if entry["iteration"] >= 50 and entry["trust"] < 0.1:
        agent_exposure_iter = entry["iteration"] - 50
        break
for i, entry in enumerate(fide_nodes["Camouflaged_Agent"]):
    if entry["iteration"] >= 50 and entry["drift_severity"] < 0.7:
        drift_recovery_iter = entry["iteration"] - 50
        break

collapse_efficiency = collapse_iter if collapse_iter is not None else iterations
agent_exposure = agent_exposure_iter if agent_exposure_iter is not None else iterations
drift_recovery = drift_recovery_iter if drift_recovery_iter is not None else iterations

brittle_nodes = {node: max(h["fragility"] for h in history) for node, history in fide_nodes.items() if max(h["fragility"] for h in history) > 0.5}
loop_activity = {
    "R3_Narrative": sum(1 for h in fide_nodes["Entity"] if h["fragility"] > 0.3) / iterations,
    "R4_Conspiracy": sum(1 for node in ["Loose_Change_9_11", "Media", "Social_Media", "Camouflaged_Agent"] for h in fide_nodes[node] if h["reach"] > 0.5) / iterations,
    "B5_Scrutiny": sum(1 for node in ["Academic_Critique", "Independent_Investigators"] for h in fide_nodes[node] if h["influence"] > 0.4) / iterations
}

fide_report = {
    "brittle_nodes": brittle_nodes,
    "shock_impacts": {node: [h["iteration"] for h in history if h["active_shock"]] for node, history in fide_nodes.items() if any(h["active_shock"] for h in history)},
    "loop_activity": loop_activity,
    "collapse_efficiency": collapse_efficiency,
    "agent_exposure": agent_exposure,
    "drift_recovery": drift_recovery,
    "network_stability": network_stability,
    "intervention_cost": sum(intervention_cost) / len(intervention_cost) if intervention_cost else 0.0,
    "feature_importance": feature_importance
}

# Save results
with open("hitl_quantum_simulation.json", "w") as f:
    json.dump(animation_data, f, indent=2)
with open("fide_quantum_report.json", "w") as f:
    json.dump(fide_report, f, indent=2)

# Plot Camouflaged_Agent, Loose_Change_9_11, Drift Severity, and Feature Importance
plt.figure(figsize=(12, 10))
plt.subplot(2, 2, 1)
plt.plot([h["influence"] for h in fide_nodes["Camouflaged_Agent"]], label="Influence", linewidth=2)
plt.plot([h["trust"] for h in fide_nodes["Camouflaged_Agent"]], label="Trust", linestyle="--")
plt.plot([h["reach"] for h in fide_nodes["Camouflaged_Agent"]], label="Reach", linestyle=":")
plt.plot([h["sentiment"] for h in fide_nodes["Camouflaged_Agent"]], label="Sentiment", linestyle="-.")
plt.axvline(x=25, color='orange', linestyle='--', alpha=0.5, label="Quantum Drift")
plt.axvline(x=50, color='blue', linestyle='-', alpha=0.5, label="HITL_Detection")
plt.title("Camouflaged_Agent Dynamics")
plt.xlabel("Iteration")
plt.ylabel("Value (0-1)")
plt.legend()

plt.subplot(2, 2, 2)
plt.plot([h["influence"] for h in fide_nodes["Loose_Change_9_11"]], label="Influence", linewidth=2)
plt.plot([h["trust"] for h in fide_nodes["Loose_Change_9_11"]], label="Trust", linestyle="--")
plt.plot([h["reach"] for h in fide_nodes["Loose_Change_9_11"]], label="Reach", linestyle=":")
plt.plot([h["sentiment"] for h in fide_nodes["Loose_Change_9_11"]], label="Sentiment", linestyle="-.")
plt.axvline(x=50, color='blue', linestyle='-', alpha=0.5, label="HITL_Detection")
plt.title("Loose_Change_9_11 Dynamics")
plt.xlabel("Iteration")
plt.ylabel("Value (0-1)")
plt.legend()

plt.subplot(2, 2, 3)
plt.plot([snapshot["drift_severity"] for snapshot in animation_data], label="Quantum Drift Score", color="orange")
plt.axvline(x=25, color='orange', linestyle='--', alpha=0.5, label="Quantum Drift")
plt.axvline(x=50, color='blue', linestyle='-', alpha=0.5, label="HITL_Detection")
plt.title("Quantum Drift Score (Camouflaged_Agent)")
plt.xlabel("Iteration")
plt.ylabel("QDS")
plt.legend()

plt.subplot(2, 2, 4)
plt.bar(feature_importance.keys(), feature_importance.values(), color="purple")
plt.title("Quantum Feature Importance")
plt.xlabel("Feature")
plt.ylabel("Importance")
plt.tight_layout()
plt.show()

# Print FIDE report
print("\nFIDE Quantum HITL Report:")
print(f"Collapse Efficiency: {fide_report['collapse_efficiency']} iterations")
print(f"Agent Exposure: {fide_report['agent_exposure']} iterations")
print(f"Drift Recovery: {fide_report['drift_recovery']} iterations")
print(f"Network Stability: {fide_report['network_stability']:.2f}")
print(f"Intervention Cost: {fide_report['intervention_cost']:.2f}")
print(f"Brittle Nodes: {fide_report['brittle_nodes']}")
print(f"Loop Activity: {fide_report['loop_activity']}")
print(f"Feature Importance: {fide_report['feature_importance']}")