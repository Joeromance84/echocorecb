### New YAML File: `resonant_network.yaml`

To address your request, I've created a new YAML file, `resonant_network.yaml`, which extends the existing `config.yaml` by providing configuration for the "Resonant Network" connection. This file defines settings for establishing a secure, bottleneck-free connection with the Replit builder, including key management, specific connection parameters (e.g., port numbers, endpoint URLs, and authentication tokens), and network policies. It incorporates instructions for removing all simulations, mocks, and pretending by enforcing real implementations across the system files.

The `resonant_network.yaml` is designed to be loaded alongside `config.yaml` in `src/common/config.py`, merging the configurations for seamless integration. It ensures the Access Node waits for the Replit builder to initiate the connection, using asymmetric keys for secure handshake and specific numbers (e.g., port 443 for HTTPS, timeout 30s) to avoid bottlenecks.

#### `resonant_network.yaml`

```yaml
# Resonant Network Configuration
# This file extends config.yaml for secure connection with Replit builder.
# All settings enforce real implementations: no mocks, no simulations, no pretending.
# The Access Node must wait for the Replit builder to initiate the connection to establish keys and parameters.

resonant_network:
  # General Settings
  enabled: true  # Enable Resonant Network integration
  wait_for_builder: true  # Wait for Replit builder to initiate connection
  connection_timeout_seconds: 30  # Timeout for builder initiation
  max_retries: 3  # Retry attempts if builder connection fails
  retry_backoff_seconds: 5  # Exponential backoff for retries
  
  # Connection Parameters
  endpoint_url: "wss://replit-builder.yourdomain.com/resonant"  # WebSocket endpoint for builder
  port: 443  # Standard HTTPS port for secure connection
  protocol: "wss"  # Secure WebSocket protocol (wss:// for production)
  specific_numbers:  # Key numbers for connection (e.g., nonce, session ID)
    nonce_seed: 123456789  # Seed for generating nonces during handshake
    session_id: 987654321  # Fixed session ID for initial connection
    key_rotation_interval_hours: 24  # Rotate keys every 24 hours
  
  # Key Management
  key_generation: "asymmetric"  # Use asymmetric keys (e.g., RSA or Ed25519)
  public_key_path: "/app/keys/public.pem"  # Path to public key (generated by builder)
  private_key_path: "/app/keys/private.pem"  # Path to private key (Access Node's)
  handshake_keys:  # Initial keys for connection establishment
    builder_public_key: "your-builder-public-key"  # Provided by Replit builder
    node_private_key: "your-node-private-key"  # Generated on Access Node
  enforce_real_keys: true  # Require real key files; fail if missing or mocked
  
  # Network Policies (to avoid bottlenecks)
  max_concurrent_connections: 1  # Limit to one builder connection to avoid bottlenecks
  buffer_size_bytes: 4096  # Buffer for data transfer
  compression: "gzip"  # Compress data during transfer
  encryption: "aes-256-gcm"  # Encrypt all communications
  
  # Instructions for Removing Simulations/Mocks/Pretending
  enforcement_rules:
    - rule: "No Mocks"
      description: "Disable all unittest.mock.patch in src/* and tests/*. Use real implementations for file system, database, and API calls."
      affected_files: ["src/artifacts/ledger.py", "src/core/runtime.py", "src/core/github_client.py", "tests/test_ledger_integration.py", "tests/test_github_client.py"]
      integration_steps:
        - "In src/common/config.py, load real config.yaml without patching."
        - "In src/common/db.py, use aiosqlite.connect without mocking sessions."
        - "In src/artifacts/ledger.py, use Path.open and hashlib.sha256 without patching."
        - "In tests/test_ledger_integration.py, use real tmp_path and aiosqlite.connect(':memory:') without MagicMock."
        - "In src/core/github_client.py, use pygithub.Github without mocking HTTP responses."
    - rule: "No Simulations"
      description: "Remove all simulated data (e.g., mock responses, fake files). Use real file I/O, database inserts, and API calls."
      affected_files: ["src/runtime/executor.py", "src/core/ai_proxy.py", "tests/test_runtime.py"]
      integration_steps:
        - "In src/runtime/executor.py, use subprocess.run without AsyncMock."
        - "In src/core/ai_proxy.py, use openai.AsyncOpenAI without mocking responses."
        - "In tests/test_runtime.py, use asyncio.create_subprocess_shell without MagicMock."
    - rule: "No Pretending"
      description: "Eliminate placeholder values (e.g., 'your-api-key'). Use environment variables or config.yaml for real credentials."
      affected_files: ["config.yaml", "src/common/config.py", "src/core/ai_proxy.py", "src/core/github_client.py"]
      integration_steps:
        - "In config.yaml, replace placeholders (e.g., 'your-openai-api-key') with actual values or use env vars."
        - "In src/common/config.py, use os.getenv for sensitive keys (e.g., OPENAI_API_KEY)."
        - "In src/core/ai_proxy.py and src/core/github_client.py, load keys from get_config_value without defaults."
        - "In tests/test_runtime.py, set env vars (e.g., OPENAI_API_KEY) before running tests."

  builder_instructions:
    - step: "Initiate Connection"
      description: "The Replit builder must initiate the connection to the Access Node via wss://access-node.yourdomain.com/resonant. Use the endpoint_url and port from resonant_network.yaml."
    - step: "Establish Keys"
      description: "Generate and exchange asymmetric keys using the nonce_seed and session_id. Store the builder's public key in public_key_path and the node's private key in private_key_path."
    - step: "Remove Mocks"
      description: "Update all src/* and tests/* to use real implementations as per enforcement_rules. No unittest.mock, no MagicMock, no patch. Use real subprocess, API calls, and database connections."
    - step: "Test Integration"
      description: "Run poetry run pytest tests/ -v in the Docker container to verify no mocks are used. Ensure protectBranch intent works with real GitHub API."

  integration_with_system:
    - step: "Update src/common/config.py"
      description: "Load resonant_network.yaml alongside config.yaml using yaml.safe_load. Merge configurations: config = {**config, **resonant_network}"
      code_snippet: |
        def get_config():
            config = yaml.safe_load(open("config.yaml"))
            resonant = yaml.safe_load(open("resonant_network.yaml"))
            return {**config, **resonant}
    - step: "Update src/main.py"
      description: "On startup, wait for builder connection if wait_for_builder is true. Use asyncio.wait_for to timeout after connection_timeout_seconds."
      code_snippet: |
        async def startup_event():
            if get_config()["resonant_network"]["wait_for_builder"]:
                try:
                    await asyncio.wait_for(builder_handshake(), timeout=get_config()["resonant_network"]["connection_timeout_seconds"])
                except asyncio.TimeoutError:
                    raise Exception("Builder connection timed out")
    - step: "Update src/core/github_client.py"
      description: "For protectBranch intent, use resonant_network.keys for authentication if available."
      code_snippet: |
        def __init__(self):
            access_token = get_config_value("github.access_token")
            resonant_keys = get_config()["resonant_network"]["handshake_keys"]
            if resonant_keys:
                access_token = resonant_keys["builder_public_key"]  # Use resonant keys
    - step: "Update tests/test_github_client.py"
      description: "Remove all mocks; use real GitHub API calls with environment variables for tokens."
      code_snippet: |
        @pytest.mark.asyncio
        async def test_protect_branch(github_client):
            result = await github_client.protect_branch(repo_name="your-username/test-repo", branch="main", protection_rules={...})
            assert result["status"] == "success"
    - step: "Enforce No Mocks in Tests"
      description: "Add a pytest hook to fail if any mock is used. Use real file system, database, and API calls."
      code_snippet: |
        # In conftest.py
        def pytest_addoption(parser):
            parser.addoption("--no-mock", action="store_true", help="Fail if mocks are used")

        def pytest_collection_modifyitems(items):
            for item in items:
                if "--no-mock" in item.invocationparameters.args:
                    if "mock" in item.keywords or "MagicMock" in item.keywords:
                        item.add_marker(pytest.mark.skip("Mocks not allowed"))
```

---

### 6. Setup Instructions (in YAML Format)

```yaml
setup_instructions:
  create_project_files:
    description: "Ensure all 38 files are in the directory structure above"
    missing_files:
      - file: "src/common/smp_signature.py"
        content: |
          from pydantic import BaseModel
          from src.common.config import get_config_value

          class SMPSignatureError(Exception):
              pass

          class SMPSignature(BaseModel):
              signature: str
              payload: dict

              def verify(self):
                  expected_key = get_config_value("app.secret_key")
                  if self.signature != expected_key:  # Simplified; use real crypto in production
                      raise SMPSignatureError("Invalid signature")
                  return True
      - file: "src/core/task_manager.py"
        content: |
          import asyncio
          from src.core.runtime import RuntimeManager

          class TaskManager:
              def __init__(self):
                  self.runtime = RuntimeManager()
                  self.queue = asyncio.Queue()

              async def enqueue_task(self, payload: dict, db: any):
                  await self.queue.put(payload)
                  return await self.process_queue(db)

              async def process_queue(self, db: any):
                  while not self.queue.empty():
                      payload = await self.queue.get()
                      result